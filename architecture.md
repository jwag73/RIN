

````markdown
# RIN (Robust Input Normalizer) - System Architecture

## 1. Project Overview

The Robust Input Normalizer (RIN) is a Python-based utility designed to pre-process potentially messy chat transcripts or markdown text. Its primary goal is to ensure that code blocks within the text are correctly identified, fenced with appropriate language tags (initially Python), and pass basic validation (like linting). This process provides more consistently formatted input for downstream tools or AI models, such as Code_Sling.

Key design principles for RIN include:
* **Self-contained:** Developed as an independent module.
* **Non-Intrusive:** Does not directly depend on Code_Sling core logic during its initial development.
* **Portable:** Designed for easy integration into various pipelines.

## 2. Directory Structure Map

The project follows an `src`-layout for its main package and a top-level `tests` directory.

```plaintext
RIN/
├── .env                      # Stores environment variables (API keys, etc.), gitignored
├── .gitignore                # Specifies intentionally untracked files for Git
├── pyproject.toml            # Build system configuration, project metadata, pytest options
├── pytest.ini                # Pytest configuration (can be used for settings not in pyproject.toml)
├── conftest.py               # Pytest hooks, used here to manage sys.path for 'src' layout
├── requirements.txt          # Python package dependencies (can supplement pyproject.toml)
├── roadmap.md                # Project development roadmap and timeline
│
├── logs/
│   └── .gitkeep              # Placeholder to keep 'logs/' in Git if initially empty
│
├── src/                      # Contains the primary source code of the application
│   └── rin/                  # The 'rin' Python package
│       ├── __init__.py       # Initializes 'rin' package, defines its public API (e.g., via __all__)
│       ├── config.py         # Defines RinConfig dataclass for application settings
│       ├── formatter.py      # Core logic for markdown segregation, tokenization, reconstruction
│       ├── model_client.py   # Wrapper for interacting with AI models (initially stubbed)
│       └── validators.py     # Contains validation functions (e.g., fence parity, linters)
│
└── tests/                    # Contains all tests for the RIN utility
    ├── __init__.py           # Makes 'tests' a Python package (can be blank)
    ├── fixtures/             # Holds test data files (e.g., sample markdown inputs/outputs)
    │   ├── __init__.py       # Makes 'fixtures' a sub-package (optional, can be blank)
    │   └── .gitkeep          # Placeholder or example fixture files
    └── unit/                 # Contains unit tests for individual modules
        ├── __init__.py       # Makes 'unit' a sub-package (can be blank)
        └── test_formatter.py # Unit tests for src/rin/formatter.py
````

## 3\. Component Descriptions

### 3.1. Root Directory Files

  * **`.env`**: Stores environment-specific configuration variables like API keys. This file is sensitive and is (and must be) listed in `.gitignore`.
  * **`.gitignore`**: Specifies intentionally untracked files and directories that Git should ignore (e.g., `.venv`, `__pycache__`, `.pytest_cache`, `.env`).
  * **`pyproject.toml`**: The standard Python project definition file. It specifies build system requirements (e.g., `setuptools`), project metadata (name, version), dependencies, and can include tool configurations (like some `pytest` options). Key for the `src`-layout and editable installs (`pip install -e .`).
  * **`pytest.ini`**: Configuration file for `pytest`. Can be used for options that are not (or not easily) configured in `pyproject.toml`. (Note: We previously attempted to use `python_paths` here, but it caused warnings; `conftest.py` is now used for path adjustments).
  * **`conftest.py`**: A special `pytest` file used for defining project-wide fixtures, hooks, and plugins. In this project, it's crucially used to programmatically add the `src/` directory to `sys.path` so that `pytest` can discover and import the `rin` package correctly.
  * **`requirements.txt`**: Lists Python package dependencies. While `pyproject.toml` is the modern standard for specifying dependencies for a library/application, `requirements.txt` is often used to pin exact versions for a specific environment or for simpler use cases.
  * **`roadmap.md`**: This document\! Outlines the project's goals, features, timeline, and current status.

### 3.2. `logs/` Directory

  * **`logs/`**: Intended for storing runtime output files, such as the JSON telemetry logs (e.g., `yyyymmdd-HHMMSS.json`) generated by RIN during its operation, as specified in the project roadmap.
      * **`.gitkeep`**: A placeholder file to ensure the `logs/` directory is tracked by Git even if it's initially empty. Actual log files might be gitignored depending on policy.

### 3.3. `src/` Directory

This directory follows the `src`-layout pattern, separating the main installable Python code from other project files.

  * **`src/rin/`**: The primary Python package for the Robust Input Normalizer.
      * **`__init__.py`**: Marks the `rin` directory as a Python package. It will define the public API of the `rin` package, likely by importing key functions and classes from its submodules and listing them in `__all__`.
      * **`config.py`**: Defines the `RinConfig` dataclass. This class will hold all configuration parameters for the RIN utility, such as model names, API timeouts, linter settings, feature flags, etc. This promotes explicit configuration passing.
      * **`formatter.py`**: Contains the core logic for processing the input markdown text. Its responsibilities include:
          * `segregate_pre_fenced_blocks()`: Identifying existing code blocks and replacing them with placeholders.
          * `tokenize_unfenced_text()`: Tokenizing the remaining text (with placeholders) for the AI model.
          * `reconstruct_markdown()`: Rebuilding the markdown document from tokens and the AI model's fencing commands, and reinserting original pre-fenced blocks.
      * **`model_client.py`**: Encapsulates interactions with external AI/Language Models.
          * Initially, this will be a stubbed or mocked client (e.g., `ModelClient` class) that returns canned responses, allowing for offline development and testing of the core RIN logic.
          * Later, it will be implemented to make actual API calls to services like OpenAI (or others as configured in `RinConfig`).
          * It will handle prompt formatting specific to the models being used for Shot-0 (initial fencing), Shot-1 (self-fix), and the big-model fallback.
      * **`validators.py`**: Contains functions for validating parts of the markdown or code blocks.
          * `fence_parity_ok()`: Checks if the markdown has an even number of code fences.
          * `extract_code_blocks()`: Extracts content from fenced code blocks (will use a markdown parser like `markdown-it-py`).
          * Linter functions (e.g., for `pylint` on Python code, or other language linters as defined in `RinConfig`).

### 3.4. `tests/` Directory

This top-level directory contains all automated tests for the RIN utility.

  * **`tests/__init__.py`**: An empty file that marks the `tests` directory as a Python package. This is good practice for test organization.
  * **`tests/fixtures/`**: This subdirectory will store any data files needed for testing (e.g., sample input markdown files, expected output files for "golden file" tests).
      * `tests/fixtures/__init__.py`: (Optional) An empty file to make `fixtures` a sub-package.
      * `tests/fixtures/.gitkeep`: Placeholder for Git if initially empty. Will be replaced by actual fixture files (e.g., `sample_chat_ messy.md`, `expected_clean_output.md`).
  * **`tests/unit/`**: This subdirectory contains unit tests, which test individual modules or functions in isolation.
      * `tests/unit/__init__.py`: An empty file that marks `unit` as a Python sub-package.
      * `tests/unit/test_formatter.py`: Contains `pytest` unit tests specifically for the functions in `src/rin/formatter.py`.
      * (Future files: `test_validators.py`, `test_config.py`, `test_model_client.py`, etc.)

## 4\. High-Level Processing Flow

The RIN utility will process input text through several stages, including segregation of existing blocks, tokenization, AI-driven fence insertion, validation, and potential self-correction or fallback.

*(This section could include the Mermaid diagram code block again if desired, or a textual description of the flow outlined in Section 2 of your `roadmap.md`.)*

```mermaid
flowchart LR
    subgraph RIN
      A[Segregate pre-fenced blocks] --> B[Tokenise Unfenced Text + Enumerate Tokens]
      B --> C[Shot-0 Mini-Model: Generate INSERT_FENCE commands]
      C --> D[Reconstruct Markdown with new fences]
      D --> E[Gate G0: Fence Parity Check (Regex)]
      E --fail--> FallbackBig[Fallback: Call Big Model once] --> D
      E --pass--> F[Gate G1: Lint + AST Checks (e.g., pylint for Python)]
      F --fail--> Fixer[Shot-1 Mini-Model: Self-fix prompt with error context] --> D
      F --pass--> Out[Output: Clean, Tagged Markdown + ValidationReport JSON]
    end
```

-----

